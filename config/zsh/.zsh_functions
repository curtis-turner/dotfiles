#!/usr/bin/env zsh
#
zmodload -F zsh/stat b:zstat
zmodload -F zsh/datetime b:strftime

autoload -Uz compinit
# Check if zcompdump was modified today (day of year comparison)
local current_day=$(date +'%j')
local dump_day=""
if [[ -f ~/.zcompdump ]]; then
    dump_day=$(strftime '%j' $(zstat +mtime ~/.zcompdump))
fi
if [[ $current_day != $dump_day ]]; then
    compinit
else
    compinit -C
fi

# Cache eval output from tools - regenerates when binary changes
# Usage: cached_eval "tool_name" "command to eval"
cached_eval() {
    local name=$1
    local cmd=$2
    local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/zsh"
    local cache_file="$cache_dir/${name}.zsh"

    [[ -d "$cache_dir" ]] || mkdir -p "$cache_dir"

    # Find the binary path
    local bin_path=$(whence -p ${name})
    if [[ -z "$bin_path" ]]; then
        return 1
    fi

    # Regenerate cache if binary is newer than cache
    if [[ ! -f "$cache_file" ]] || [[ "$bin_path" -nt "$cache_file" ]]; then
        eval "$cmd" > "$cache_file" 2>/dev/null
    fi

    source "$cache_file"
}

c() {
  cd $CODE_DIR/$1
}

_c() {
  _files -W $CODE_DIR -/
}
compdef _c c

h() {
  cd $HOME/$1
}

_h() {
  _files -W $HOME -/
}
compdef _h h

g() {
  if [[ $# > 0 ]]; then
      # if there are arguments, send them to git
      git $@
  else
      # otherwise, run git status
      git s
  fi
}

last_modified() {
  ls -lt $1 | head -n 2 | tail -n 1 | awk '{print $6, $7, $8}'
}

md() {
  mkdir -p $1
  cd $1
}

prepend_path() {
  [[ ! -d "$1" ]] && return

  path=(
      $1
      $path
  )
}

# Activate mise environment only when config file is present (used with shims mode)
# Caches based on config file mtime to avoid unnecessary subprocess calls
typeset -g _mise_last_config_mtime=""
_mise_chpwd_hook() {
    local config_file=""
    local current_mtime=""

    # Find the first existing config file
    for f in .mise.toml mise.toml .mise.local.toml .tool-versions; do
        if [[ -f $f ]]; then
            config_file=$f
            break
        fi
    done

    [[ -z $config_file ]] && return

    # Get mtime using zstat (loaded at top of file)
    current_mtime="${PWD}:$(zstat +mtime $config_file 2>/dev/null)"

    # Only run mise if config changed
    if [[ $_mise_last_config_mtime != $current_mtime ]]; then
        _mise_last_config_mtime=$current_mtime
        eval "$(mise hook-env -s zsh 2>/dev/null)"
    fi
}

# Terminal colors for zfetch (defined once, not per-call)
typeset -g _zf_Rst=$'\e[0m'
typeset -g _zf_Red=$'\e[31m'
typeset -g _zf_Yel=$'\e[33m'
typeset -g _zf_Blu=$'\e[34m'

zfetch() {
  git_clone_error_msg() {
      echo -e "  ${_zf_Red}[ERROR]${_zf_Rst} git clone errored: ${_zf_Red}${1}${_zf_Rst}. ${_zf_Yel}aborting...${_zf_Rst}"
  }

  # Simplest dependency fetcher known to mankind
  if [[ $1 == "update" ]]; then
      for name in ${(@k)plugins}; do
          local cwd=$(pwd)
          local dest=$plugins[$name]
          cd $dest
          echo -e "Updating ${_zf_Yel}${name}${_zf_Rst}..."
          git pull --quiet --recurse-submodules
          cd $cwd
      done
  elif [[ $1 == "ls" ]]; then
      for name in ${(@k)plugins}; do
          echo -e "${name}: ${_zf_Yel}$plugins[$name]${_zf_Rst}"
      done
  else

    # the short name of the repo (org/repo)
    local name="$1"

    local plugin_name="${2:-"${name##*/}.plugin.zsh"}"

    # where the repo is going
    local dest="${3:-"$ZPLUGDIR"}"

    # if the dest dir ends with /, append the name to it to get the real dest dir
    if [[ $dest == */ ]]; then
        dest=$dest$name
    else
        dest=$dest/$name
    fi

    local cwd=$(pwd)
    plugins[$name]=$dest

    if [[ ! -d $dest ]]; then
        local url=git@github.com:$name
        local ref=$3
        echo -e "Missing plugin ${_zf_Yel}${name}${_zf_Rst}"
        echo -e "  Cloning from ${_zf_Blu}${url}${_zf_Rst}..."
        if [[ -n $ref ]]; then
            git clone --quiet $url $dest
            if [[ $? != 0 ]]; then
                git_clone_error_msg $?
                cd $cwd
                return $?
            fi

            git checkout --quiet $ref
            echo -e "  Checked out branch ${_zf_Yel}${ref}${_zf_Rst}"
        else
            git clone --quiet --depth 1 $url $dest
            if [[ $? != 0 ]]; then
                git_clone_error_msg $?
                cd $cwd
                return $?
            fi
            echo -e "  Checked out default branch"
        fi
    fi
    plugin="$dest/$plugin_name"
    if [ -f "$plugin" ]; then
        source "$plugin"
    fi
    cd $cwd
  fi
}

